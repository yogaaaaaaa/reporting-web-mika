import r from"jsep";export{default as parse}from"jsep";const n={"||":1,"&&":2,"|":3,"^":4,"&":5,"==":6,"!=":6,"===":6,"!==":6,"<":7,">":7,"<=":7,">=":7,"<<":8,">>":8,">>>":8,"+":9,"-":9,"*":10,"/":10,"%":10},e={"||":function(r,n){return r||n},"&&":function(r,n){return r&&n},"|":function(r,n){return r|n},"^":function(r,n){return r^n},"&":function(r,n){return r&n},"==":function(r,n){return r==n},"!=":function(r,n){return r!=n},"===":function(r,n){return r===n},"!==":function(r,n){return r!==n},"<":function(r,n){return r<n},">":function(r,n){return r>n},"<=":function(r,n){return r<=n},">=":function(r,n){return r>=n},"<<":function(r,n){return r<<n},">>":function(r,n){return r>>n},">>>":function(r,n){return r>>>n},"+":function(r,n){return r+n},"-":function(r,n){return r-n},"*":function(r,n){return r*n},"/":function(r,n){return r/n},"%":function(r,n){return r%n}},t={"-":function(r){return-r},"+":function(r){return+r},"~":function(r){return~r},"!":function(r){return!r}};function a(r,n){return r.map(function(r){return s(r,n)})}async function i(r,n){return await Promise.all(r.map(r=>c(r,n)))}function u(r,n){const e=s(r.object,n);return r.computed?[e,e[s(r.property,n)]]:[e,e[r.property.name]]}async function o(r,n){const e=await c(r.object,n);return r.computed?[e,e[await c(r.property,n)]]:[e,e[r.property.name]]}function s(r,n){const i=r;switch(i.type){case"ArrayExpression":return a(i.elements,n);case"BinaryExpression":return e[i.operator](s(i.left,n),s(i.right,n));case"CallExpression":let r,o,c;if("MemberExpression"===i.callee.type?(c=u(i.callee,n),r=c[0],o=c[1]):o=s(i.callee,n),"function"!=typeof o)return;return o.apply(r,a(i.arguments,n));case"ConditionalExpression":return s(i.test,n)?s(i.consequent,n):s(i.alternate,n);case"Identifier":return n[i.name];case"Literal":return i.value;case"LogicalExpression":return"||"===i.operator?s(i.left,n)||s(i.right,n):"&&"===i.operator?s(i.left,n)&&s(i.right,n):e[i.operator](s(i.left,n),s(i.right,n));case"MemberExpression":return u(i,n)[1];case"ThisExpression":return n;case"UnaryExpression":return t[i.operator](s(i.argument,n));default:return}}async function c(r,n){const a=r;switch(a.type){case"ArrayExpression":return await i(a.elements,n);case"BinaryExpression":{const[r,t]=await Promise.all([c(a.left,n),c(a.right,n)]);return e[a.operator](r,t)}case"CallExpression":{let r,e,t;if("MemberExpression"===a.callee.type?(t=await o(a.callee,n),r=t[0],e=t[1]):e=await c(a.callee,n),"function"!=typeof e)return;return await e.apply(r,await i(a.arguments,n))}case"ConditionalExpression":return await c(a.test,n)?await c(a.consequent,n):await c(a.alternate,n);case"Identifier":return n[a.name];case"Literal":return a.value;case"LogicalExpression":{if("||"===a.operator)return await c(a.left,n)||await c(a.right,n);if("&&"===a.operator)return await c(a.left,n)&&await c(a.right,n);const[r,t]=await Promise.all([c(a.left,n),c(a.right,n)]);return e[a.operator](r,t)}case"MemberExpression":return(await o(a,n))[1];case"ThisExpression":return n;case"UnaryExpression":return t[a.operator](await c(a.argument,n));default:return}}function f(n){return s.bind(null,r(n))}function p(n){return c.bind(null,r(n))}function l(n,e){r.addUnaryOp(n),t[n]=e}function m(t,a,i){i?(r.addBinaryOp(t,a),e[t]=i):(r.addBinaryOp(t,n[t]||1),e[t]=a)}export{m as addBinaryOp,l as addUnaryOp,f as compile,p as compileAsync,s as eval,c as evalAsync};
//# sourceMappingURL=expression-eval.modern.js.map
