{"version":3,"file":"expression-eval.modern.js","sources":["../index.ts"],"sourcesContent":["import jsep from 'jsep';\n\n/**\n * Evaluation code from JSEP project, under MIT License.\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\n */\n\n// Default operator precedence from https://github.com/EricSmekens/jsep/blob/master/src/jsep.js#L55\nconst DEFAULT_PRECEDENCE = {\n  '||': 1,\n  '&&': 2,\n  '|': 3,\n  '^': 4,\n  '&': 5,\n  '==': 6,\n  '!=': 6,\n  '===': 6,\n  '!==': 6,\n  '<': 7,\n  '>': 7,\n  '<=': 7,\n  '>=': 7,\n  '<<': 8,\n  '>>': 8,\n  '>>>': 8,\n  '+': 9,\n  '-': 9,\n  '*': 10,\n  '/': 10,\n  '%': 10\n};\n\nconst binops = {\n  '||': function (a, b) { return a || b; },\n  '&&': function (a, b) { return a && b; },\n  '|': function (a, b) { return a | b; },\n  '^': function (a, b) { return a ^ b; },\n  '&': function (a, b) { return a & b; },\n  '==': function (a, b) { return a == b; }, // jshint ignore:line\n  '!=': function (a, b) { return a != b; }, // jshint ignore:line\n  '===': function (a, b) { return a === b; },\n  '!==': function (a, b) { return a !== b; },\n  '<': function (a, b) { return a < b; },\n  '>': function (a, b) { return a > b; },\n  '<=': function (a, b) { return a <= b; },\n  '>=': function (a, b) { return a >= b; },\n  '<<': function (a, b) { return a << b; },\n  '>>': function (a, b) { return a >> b; },\n  '>>>': function (a, b) { return a >>> b; },\n  '+': function (a, b) { return a + b; },\n  '-': function (a, b) { return a - b; },\n  '*': function (a, b) { return a * b; },\n  '/': function (a, b) { return a / b; },\n  '%': function (a, b) { return a % b; }\n};\n\nconst unops = {\n  '-': function (a) { return -a; },\n  '+': function (a) { return +a; },\n  '~': function (a) { return ~a; },\n  '!': function (a) { return !a; },\n};\n\ndeclare type operand = number | string;\ndeclare type unaryCallback = (a: operand) => operand;\ndeclare type binaryCallback = (a: operand, b: operand) => operand;\n\ntype AnyExpression = jsep.ArrayExpression\n  | jsep.BinaryExpression\n  | jsep.MemberExpression\n  | jsep.CallExpression\n  | jsep.ConditionalExpression\n  | jsep.Identifier\n  | jsep.Literal\n  | jsep.LogicalExpression\n  | jsep.ThisExpression\n  | jsep.UnaryExpression;\n\nfunction evaluateArray(list, context) {\n  return list.map(function (v) { return evaluate(v, context); });\n}\n\nasync function evaluateArrayAsync(list, context) {\n  const res = await Promise.all(list.map((v) => evalAsync(v, context)));\n  return res;\n}\n\nfunction evaluateMember(node: jsep.MemberExpression, context: object) {\n  const object = evaluate(node.object, context);\n  if (node.computed) {\n    return [object, object[evaluate(node.property, context)]];\n  } else {\n    return [object, object[(node.property as jsep.Identifier).name]];\n  }\n}\n\nasync function evaluateMemberAsync(node: jsep.MemberExpression, context: object) {\n  const object = await evalAsync(node.object, context);\n  if (node.computed) {\n    return [object, object[await evalAsync(node.property, context)]];\n  } else {\n    return [object, object[(node.property as jsep.Identifier).name]];\n  }\n}\n\nfunction evaluate(_node: jsep.Expression, context: object) {\n\n  const node = _node as AnyExpression;\n\n  switch (node.type) {\n\n    case 'ArrayExpression':\n      return evaluateArray(node.elements, context);\n\n    case 'BinaryExpression':\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\n\n    case 'CallExpression':\n      let caller, fn, assign;\n      if (node.callee.type === 'MemberExpression') {\n        assign = evaluateMember(node.callee as jsep.MemberExpression, context);\n        caller = assign[0];\n        fn = assign[1];\n      } else {\n        fn = evaluate(node.callee, context);\n      }\n      if (typeof fn !== 'function') { return undefined; }\n      return fn.apply(caller, evaluateArray(node.arguments, context));\n\n    case 'ConditionalExpression':\n      return evaluate(node.test, context)\n        ? evaluate(node.consequent, context)\n        : evaluate(node.alternate, context);\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression':\n      if (node.operator === '||') {\n        return evaluate(node.left, context) || evaluate(node.right, context);\n      } else if (node.operator === '&&') {\n        return evaluate(node.left, context) && evaluate(node.right, context);\n      }\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\n\n    case 'MemberExpression':\n      return evaluateMember(node, context)[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[node.operator](evaluate(node.argument, context));\n\n    default:\n      return undefined;\n  }\n\n}\n\nasync function evalAsync(_node: jsep.Expression, context: object) {\n\n  const node = _node as AnyExpression;\n\n  // Brackets used for some case blocks here, to avoid edge cases related to variable hoisting.\n  // See: https://stackoverflow.com/questions/57759348/const-and-let-variable-shadowing-in-a-switch-statement\n  switch (node.type) {\n\n    case 'ArrayExpression':\n      return await evaluateArrayAsync(node.elements, context);\n\n    case 'BinaryExpression': {\n      const [left, right] = await Promise.all([\n        evalAsync(node.left, context),\n        evalAsync(node.right, context)\n      ]);\n      return binops[node.operator](left, right);\n    }\n\n    case 'CallExpression': {\n      let caller, fn, assign;\n      if (node.callee.type === 'MemberExpression') {\n        assign = await evaluateMemberAsync(node.callee as jsep.MemberExpression, context);\n        caller = assign[0];\n        fn = assign[1];\n      } else {\n        fn = await evalAsync(node.callee, context);\n      }\n      if (typeof fn !== 'function') {\n        return undefined;\n      }\n      return await fn.apply(\n        caller,\n        await evaluateArrayAsync(node.arguments, context)\n      );\n    }\n\n    case 'ConditionalExpression':\n      return (await evalAsync(node.test, context))\n        ? await evalAsync(node.consequent, context)\n        : await evalAsync(node.alternate, context);\n\n    case 'Identifier':\n      return context[node.name];\n\n    case 'Literal':\n      return node.value;\n\n    case 'LogicalExpression': {\n      if (node.operator === '||') {\n        return (\n          (await evalAsync(node.left, context)) ||\n          (await evalAsync(node.right, context))\n        );\n      } else if (node.operator === '&&') {\n        return (\n          (await evalAsync(node.left, context)) &&\n          (await evalAsync(node.right, context))\n        );\n      }\n\n      const [left, right] = await Promise.all([\n        evalAsync(node.left, context),\n        evalAsync(node.right, context)\n      ]);\n\n      return binops[node.operator](left, right);\n    }\n\n    case 'MemberExpression':\n      return (await evaluateMemberAsync(node, context))[1];\n\n    case 'ThisExpression':\n      return context;\n\n    case 'UnaryExpression':\n      return unops[node.operator](await evalAsync(node.argument, context));\n\n    default:\n      return undefined;\n  }\n}\n\nfunction compile(expression: string | jsep.Expression): (context: object) => any {\n  return evaluate.bind(null, jsep(expression));\n}\n\nfunction compileAsync(expression: string | jsep.Expression): (context: object) => Promise<any> {\n  return evalAsync.bind(null, jsep(expression));\n}\n\n// Added functions to inject Custom Unary Operators (and override existing ones)\nfunction addUnaryOp(operator: string, _function: unaryCallback): void {\n  jsep.addUnaryOp(operator);\n  unops[operator] = _function;\n}\n\n// Added functions to inject Custom Binary Operators (and override existing ones)\nfunction addBinaryOp(operator: string, precedence_or_fn: number | binaryCallback, _function: binaryCallback): void {\n  if (_function) {\n    jsep.addBinaryOp(operator, precedence_or_fn as number);\n    binops[operator] = _function;\n  } else {\n    jsep.addBinaryOp(operator, DEFAULT_PRECEDENCE[operator] || 1);\n    binops[operator] = precedence_or_fn;\n  }\n}\n\nexport {\n  jsep as parse,\n  evaluate as eval,\n  evalAsync,\n  compile,\n  compileAsync,\n  addUnaryOp,\n  addBinaryOp\n};\n"],"names":["DEFAULT_PRECEDENCE","||","&&","|","^","&","==","!=","===","!==","<",">","<=",">=","<<",">>",">>>","+","-","*","/","%","binops","a","b","unops","~","!","evaluateArray","list","context","map","v","evaluate","async","evaluateArrayAsync","Promise","all","evalAsync","evaluateMember","node","object","computed","property","name","evaluateMemberAsync","_node","type","elements","operator","left","right","caller","fn","assign","callee","apply","arguments","test","consequent","alternate","value","argument","compile","expression","bind","jsep","compileAsync","addUnaryOp","_function","addBinaryOp","precedence_or_fn"],"mappings":"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"}